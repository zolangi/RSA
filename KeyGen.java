package project2;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.math.BigInteger;
import java.util.Random;

/**
 * @author Zolangi Ramirez
 * @author Phillip Gulegin
 */

public class KeyGen {
	static BigInteger p,q,n,totient;
	
	public static void main(String[] args) {
		Random rnd = new Random();	// random number
		int bitLength = 512;	// recommended bit length for p and q
		p = BigInteger.probablePrime(bitLength, rnd);  	// create p, as a random prime
		q = BigInteger.probablePrime(bitLength, rnd);	// create q, as a random prime
		n = p.multiply(q);	// the size n by p x q 
		//System.out.println("p: " + p +"\nq: " + q);
		totient = p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE)); // totient function calculated by (p-1)x(q-1) 
		BigInteger e = genE(totient, bitLength, rnd); // assign e to value generated by genE()
		BigInteger d = e.modInverse(totient);	// is the inverse of e modulo totient(n)
		
		System.out.println("e: " + e + "\nd: " + d + "\nn: " + n);
		
		try {
			privateKey(d,n);
			publicKey(e,n);
		} catch (IOException e1) {
			e1.printStackTrace();
		}
	} 

	// returns true if the gcd is equal to one, else returns false
	public static boolean gcdIsOne(BigInteger e, BigInteger totient){
		boolean isOne= false;	// boolean to check whether the gcd is one
		
		BigInteger gcd = e.gcd(totient);	// gcd finds the gcd(e, totient)
				
		if(gcd.compareTo(BigInteger.ONE) == 0)	// checks if gcd is equal to one
			isOne = true;	//if gcd = 1, then set boolean to true
		else
			isOne = false;
				
		return isOne;	// return boolean value
	}
	
	// generates e
	public static BigInteger genE (BigInteger totient, int bitLength, Random rnd){
		BigInteger temp = BigInteger.probablePrime(bitLength, rnd);	// random prime for temporary use in this method		
		BigInteger e = null;	// instantiate e
		boolean gcd = gcdIsOne(temp, totient);	// returns true if temp is a coprime of the totient
		
		// checks 1 < temp < gcd = 1 
		if((temp.compareTo(BigInteger.ONE) == 1) && temp.compareTo(totient) == -1 && gcd == true ){
			e = temp; // set e value to equal the temp value that satisfies the three conditions
			return e;
		}
		else{
			// if 1 < temp < gcd = 1 is not satisified make a recursive call until you find a 
			// temp value that meets the 3 conditions
			genE(totient, bitLength, rnd);
		}
		return e;
	}
	
	public static void publicKey(BigInteger e, BigInteger n) throws IOException{

		// Create file and object streams
		FileOutputStream fileOutStream = new FileOutputStream("pubkey.rsa");
        ObjectOutputStream objectOutStream = new ObjectOutputStream(fileOutStream);
        
        // Write BigInts to file
        objectOutStream.writeObject(e.toByteArray());
        objectOutStream.writeObject(n.toByteArray());
        
        // Close the stream
        objectOutStream.close();
	}
	
	public static void privateKey(BigInteger d, BigInteger n) throws IOException{

		// Create file and object streams
		FileOutputStream fileOutStream = new FileOutputStream("privkey.rsa");
		ObjectOutputStream objectOutStream = new ObjectOutputStream(fileOutStream);
		
		// Write BigInts to file
        objectOutStream.writeObject(d.toByteArray());
        objectOutStream.writeObject(n.toByteArray());

        // Close the stream
        objectOutStream.close();
	}

}
